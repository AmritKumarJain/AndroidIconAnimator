<html>
  <body>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
    <div class="info"></div>
    <canvas width="2000" height="1000" style="width: 1000px; height: 500px;">
    <script>
      let points = (localStorage.bezier ? JSON.parse(localStorage.bezier) : null) || [
        {
          point: {x: 20, y: 250},
          control: {x: 250, y: 480}
        },
        {
          point: {x: 480, y: 250},
          control: {x: 250, y: 20}
        }
      ];

      let canvas = document.querySelector('canvas');
      let ctx = canvas.getContext('2d');
      ctx.scale(2, 2);
      let downPoint = null;
      let origPoint = null;
      let downControlPoint = null;
      let origControlPoint = null;
      let downEvent;

      $(canvas)
          .on('mousedown', event => {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            points.forEach(point => {
              if (Math.abs(point.control.x - x) < 10 && Math.abs(point.control.y - y) < 10) {
                downEvent = event;
                downControlPoint = point.control;
                origControlPoint = Object.assign({}, downControlPoint);
              } else if (Math.abs(point.point.x - x) < 10 && Math.abs(point.point.y - y) < 10) {
                downEvent = event;
                downPoint = point.point;
                origPoint = Object.assign({}, downPoint);
                downControlPoint = point.control;
                origControlPoint = Object.assign({}, downControlPoint);
              }
            });

            let mouseMoveHandler_ = event => {
              if (downPoint) {
                downPoint.x = origPoint.x + (event.clientX - downEvent.clientX);
                downPoint.y = origPoint.y + (event.clientY - downEvent.clientY);
              }
              if (downControlPoint) {
                downControlPoint.x = origControlPoint.x + (event.clientX - downEvent.clientX);
                downControlPoint.y = origControlPoint.y + (event.clientY - downEvent.clientY);
              }
              redraw();
            };

            let mouseUpHandler_ = event => {
              downPoint = null;
              downControlPoint = null;
              downEvent = null;
              $(window)
                  .off('mousemove', mouseMoveHandler_)
                  .off('mouseup', mouseUpHandler_);
              localStorage.bezier = JSON.stringify(points);
            };

            if (downEvent) {
              $(window)
                  .on('mousemove', mouseMoveHandler_)
                  .on('mouseup', mouseUpHandler_);
            }
          });

      let drawBezier = (p1, cp1, cp2, p2, length) => {
        ctx.save();

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.stroke();

        ctx.setLineDash([15, length - 30]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
        ctx.strokeStyle = '#08f';
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.setLineDash([]);

        drawLine(p1, cp1);
        drawLine(p2, cp2);
        drawDot(p1);
        drawDot(p2);
        drawDot(cp1);
        drawDot(cp2);

        ctx.restore();
      };

      let drawDot = (p, color, size) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size || 2, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.strokeStyle = color || 'red';
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.fill();
      };

      let drawLine = (p1, p2, color) => {
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color || 'red';
        ctx.stroke();
      };

      let redraw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let maxError = dist(points[0].point, points[1].point) / 500;

        // recompute path length
        let length = recomputeBezierLength(
            points[0].point, points[0].control, points[1].control, points[1].point,
            maxError, true);

        let lengthCrazy = recomputeBezierLengthSimple(
            points[0].point, points[0].control, points[1].control, points[1].point,
            100000);

        drawBezier(points[0].point, points[0].control, points[1].control, points[1].point, length);

        $('.info').text(`opt: ${length.toFixed(2)}, error: ${(length - lengthCrazy).toFixed(2)}, maxError: ${maxError.toFixed(2)}`);
      };

      let dist = (p1, p2) => {
        return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
      };

      let recomputeBezierLength = (p1, cp1, cp2, p2, thresholdPx, draw) => {
        thresholdPx = Math.max(1, thresholdPx);

        let pointAlongBezier_ = t => {
          return {
            x: Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * cp1.x + 3 * (1 - t) * Math.pow(t, 2) * cp2.x + Math.pow(t, 3) * p2.x,
            y: Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * cp1.y + 3 * (1 - t) * Math.pow(t, 2) * cp2.y + Math.pow(t, 3) * p2.y
          };
        };

        let regionDist_ = (t1, t2) => {
          let regionThresh = thresholdPx * (t2 - t1);
          let lineDist = dist(pointAlongBezier_(t1), pointAlongBezier_(t2));

          let tMid = t1 + (t2 - t1) / 2;
          let subdivDist = dist(pointAlongBezier_(t1), pointAlongBezier_(tMid))
              + dist(pointAlongBezier_(tMid), pointAlongBezier_(t2));

          if (Math.abs(subdivDist - lineDist) < regionThresh) {
            if (draw) {
              drawLine(pointAlongBezier_(t1), pointAlongBezier_(t2), '#888');
              drawDot(pointAlongBezier_(t1), '#888', 1);
            }
            return lineDist;

          } else {
            return regionDist_(t1, tMid) + regionDist_(tMid, t2);
          }
        }

        return regionDist_(0, .25)
            + regionDist_(.25, .5)
            + regionDist_(.5, .75)
            + regionDist_(.75, 1);
      };

      let recomputeBezierLengthSimple = (p1, cp1, cp2, p2, steps) => {
        let pointAlongBezier_ = t => {
          return {
            x: Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * cp1.x + 3 * (1 - t) * Math.pow(t, 2) * cp2.x + Math.pow(t, 3) * p2.x,
            y: Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * cp1.y + 3 * (1 - t) * Math.pow(t, 2) * cp2.y + Math.pow(t, 3) * p2.y
          };
        };

        let length = 0;
        for (let i = 0; i < steps; i++) {
          length += dist(
              pointAlongBezier_(i * 1 / steps),
              pointAlongBezier_((i + 1) * 1 / steps));
        }

        return length;
      };

      redraw();

    </script>
  </body>
</html>