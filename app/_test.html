<html>
<body>


<!--<svg width="200px" height="200px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Artboard 1</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill-rule="evenodd" stroke-linecap="square">
      <line x1="20" y1="100" x2="100" y2="20" stroke="black" stroke-width="2" />
      <rect fill="red" fill-opacity=".2" x="10" y="10" width="100" height="100" />
      <polygon points="60,20 100,40 100,80 60,100 20,80 20,40" />
      <ellipse fill="green" fill-opacity=".2" cx="60" cy="120" rx="50" ry="25" />
      <circle fill="blue" fill-opacity=".2" cx="60" cy="60" r="50" />
      <path d="M 60,95 A 50 25 0 1 0 60,145 A 50 25 0 1 0 60,95 Z" fill="purple" />
      <polyline fill="none" stroke="black" points="20,100 40,60 70,80 100,20" />

      <g id="Artboard-1" stroke="#000000" stroke-width="2">
        <g id="arrow" transform="translate(5.000000, 5.000000)">
          <path d="M7,0.409999847 L13.59,7" id="bottom"></path>
          <path d="M7,13.5900002 L13.59,7" id="top"></path>
          <path d="M0,7 L13,7" id="stem"></path>
        </g>
        <g id="menu" transform="translate(4.000000, 6.000000)">
          <path d="M0,1 L16,1" id="top"></path>
          <path d="M0,11 L16,11" id="bottom"></path>
          <path d="M0,6 L16,6" id="stem"></path>
        </g>
      </g>
    </g>
</svg>-->


  <script>
/**
* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
*  
* Version - 0.99.00.beta 
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/vkbeautify/
* 
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*   Pretty print
*
*        vkbeautify.xml(text [,indent_pattern]);
*        vkbeautify.json(text [,indent_pattern]);
*        vkbeautify.css(text [,indent_pattern]);
*        vkbeautify.sql(text [,indent_pattern]);
*
*        @text - String; text to beatufy;
*        @indent_pattern - Integer | String;
*                Integer:  number of white spaces;
*                String:   character string to visualize indentation ( can also be a set of white spaces )
*   Minify
*
*        vkbeautify.xmlmin(text [,preserve_comments]);
*        vkbeautify.jsonmin(text);
*        vkbeautify.cssmin(text [,preserve_comments]);
*        vkbeautify.sqlmin(text);
*
*        @text - String; text to minify;
*        @preserve_comments - Bool; [optional];
*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )
*
*   Examples:
*        vkbeautify.xml(text); // pretty print XML
*        vkbeautify.json(text, 4 ); // pretty print JSON
*        vkbeautify.css(text, '. . . .'); // pretty print CSS
*        vkbeautify.sql(text, '----'); // pretty print SQL
*
*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments
*        vkbeautify.jsonmin(text);// minify JSON
*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )
*        vkbeautify.sqlmin(text);// minify SQL
*
*/
function createShiftArr(step) {

  var space = '    ';
  
  if ( isNaN(parseInt(step)) ) {  // argument is string
    space = step;
  } else { // argument is integer
    switch(step) {
      case 1: space = ' '; break;
      case 2: space = '  '; break;
      case 3: space = '   '; break;
      case 4: space = '    '; break;
      case 5: space = '     '; break;
      case 6: space = '      '; break;
      case 7: space = '       '; break;
      case 8: space = '        '; break;
      case 9: space = '         '; break;
      case 10: space = '          '; break;
      case 11: space = '           '; break;
      case 12: space = '            '; break;
    }
  }

  var shift = ['\n']; // array of shifts
  for(ix=0;ix<100;ix++){
    shift.push(shift[ix]+space); 
  }
  return shift;
}

function vkbeautify(){
  this.step = '    '; // 4 spaces
  this.shift = createShiftArr(this.step);
};

vkbeautify.prototype.xml = function(text,step) {

  var ar = text.replace(/>\s{0,}</g,"><")
         .replace(/</g,"~::~<")
         .replace(/\s*xmlns\:/g,"~::~xmlns:")
         .replace(/\s*xmlns\=/g,"~::~xmlns=")
         .split('~::~'),
    len = ar.length,
    inComment = false,
    deep = 0,
    str = '',
    ix = 0,
    shift = step ? createShiftArr(step) : this.shift;

    for(ix=0;ix<len;ix++) {
      // start comment or <![CDATA[...]]> or <!DOCTYPE //
      if(ar[ix].search(/<!/) > -1) { 
        str += shift[deep]+ar[ix];
        inComment = true; 
        // end comment  or <![CDATA[...]]> //
        if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) { 
          inComment = false; 
        }
      } else 
      // end comment  or <![CDATA[...]]> //
      if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) { 
        str += ar[ix];
        inComment = false; 
      } else 
      // <elm></elm> //
      if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
        /^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) { 
        str += ar[ix];
        if(!inComment) deep--;
      } else
       // <elm> //
      if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
        str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
      } else 
       // <elm>...</elm> //
      if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
        str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
      } else 
      // </elm> //
      if(ar[ix].search(/<\//) > -1) { 
        str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
      } else 
      // <elm/> //
      if(ar[ix].search(/\/>/) > -1 ) { 
        str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
      } else 
      // <? xml ... ?> //
      if(ar[ix].search(/<\?/) > -1) { 
        str += shift[deep]+ar[ix];
      } else 
      // xmlns //
      if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) { 
        str += shift[deep]+ar[ix];
      } 
      
      else {
        str += ar[ix];
      }
    }
    
  return  (str[0] == '\n') ? str.slice(1) : str;
}

vkbeautify.prototype.json = function(text,step) {

  var step = step ? step : this.step;
  
  if (typeof JSON === 'undefined' ) return text; 
  
  if ( typeof text === "string" ) return JSON.stringify(JSON.parse(text), null, step);
  if ( typeof text === "object" ) return JSON.stringify(text, null, step);
    
  return text; // text is not string nor object
}

vkbeautify.prototype.css = function(text, step) {

  var ar = text.replace(/\s{1,}/g,' ')
        .replace(/\{/g,"{~::~")
        .replace(/\}/g,"~::~}~::~")
        .replace(/\;/g,";~::~")
        .replace(/\/\*/g,"~::~/*")
        .replace(/\*\//g,"*/~::~")
        .replace(/~::~\s{0,}~::~/g,"~::~")
        .split('~::~'),
    len = ar.length,
    deep = 0,
    str = '',
    ix = 0,
    shift = step ? createShiftArr(step) : this.shift;
    
    for(ix=0;ix<len;ix++) {

      if( /\{/.exec(ar[ix]))  { 
        str += shift[deep++]+ar[ix];
      } else 
      if( /\}/.exec(ar[ix]))  { 
        str += shift[--deep]+ar[ix];
      } else
      if( /\*\\/.exec(ar[ix]))  { 
        str += shift[deep]+ar[ix];
      }
      else {
        str += shift[deep]+ar[ix];
      }
    }
    return str.replace(/^\n{1,}/,'');
}

//----------------------------------------------------------------------------

function isSubquery(str, parenthesisLevel) {
  return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}

function split_sql(str, tab) {

  return str.replace(/\s{1,}/g," ")

        .replace(/ AND /ig,"~::~"+tab+tab+"AND ")
        .replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
        .replace(/ CASE /ig,"~::~"+tab+"CASE ")
        .replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
        .replace(/ END /ig,"~::~"+tab+"END ")
        .replace(/ FROM /ig,"~::~FROM ")
        .replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
        .replace(/ HAVING /ig,"~::~HAVING ")
        //.replace(/ SET /ig," SET~::~")
        .replace(/ IN /ig," IN ")
        
        .replace(/ JOIN /ig,"~::~JOIN ")
        .replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
        .replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
        .replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
        .replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")
        
        .replace(/ ON /ig,"~::~"+tab+"ON ")
        .replace(/ OR /ig,"~::~"+tab+tab+"OR ")
        .replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
        .replace(/ OVER /ig,"~::~"+tab+"OVER ")

        .replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
        .replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")
        
        .replace(/ THEN /ig," THEN~::~"+tab+"")
        .replace(/ UNION /ig,"~::~UNION~::~")
        .replace(/ USING /ig,"~::~USING ")
        .replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
        .replace(/ WHERE /ig,"~::~WHERE ")
        .replace(/ WITH /ig,"~::~WITH ")
        
        //.replace(/\,\s{0,}\(/ig,",~::~( ")
        //.replace(/\,/ig,",~::~"+tab+tab+"")

        .replace(/ ALL /ig," ALL ")
        .replace(/ AS /ig," AS ")
        .replace(/ ASC /ig," ASC ") 
        .replace(/ DESC /ig," DESC ") 
        .replace(/ DISTINCT /ig," DISTINCT ")
        .replace(/ EXISTS /ig," EXISTS ")
        .replace(/ NOT /ig," NOT ")
        .replace(/ NULL /ig," NULL ")
        .replace(/ LIKE /ig," LIKE ")
        .replace(/\s{0,}SELECT /ig,"SELECT ")
        .replace(/\s{0,}UPDATE /ig,"UPDATE ")
        .replace(/ SET /ig," SET ")
              
        .replace(/~::~{1,}/g,"~::~")
        .split('~::~');
}

vkbeautify.prototype.sql = function(text,step) {

  var ar_by_quote = text.replace(/\s{1,}/g," ")
              .replace(/\'/ig,"~::~\'")
              .split('~::~'),
    len = ar_by_quote.length,
    ar = [],
    deep = 0,
    tab = this.step,//+this.step,
    inComment = true,
    inQuote = false,
    parenthesisLevel = 0,
    str = '',
    ix = 0,
    shift = step ? createShiftArr(step) : this.shift;;

    for(ix=0;ix<len;ix++) {
      if(ix%2) {
        ar = ar.concat(ar_by_quote[ix]);
      } else {
        ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
      }
    }
    
    len = ar.length;
    for(ix=0;ix<len;ix++) {
      
      parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);
      
      if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
        ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
      } 
      
      if( /\s{0,}\s{0,}SET\s{0,}/.exec(ar[ix]))  { 
        ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
      } 
      
      if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
        deep++;
        str += shift[deep]+ar[ix];
      } else 
      if( /\'/.exec(ar[ix]) )  { 
        if(parenthesisLevel<1 && deep) {
          deep--;
        }
        str += ar[ix];
      }
      else  { 
        str += shift[deep]+ar[ix];
        if(parenthesisLevel<1 && deep) {
          deep--;
        }
      } 
      var junk = 0;
    }

    str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
    return str;
}


vkbeautify.prototype.xmlmin = function(text, preserveComments) {

  var str = preserveComments ? text
                 : text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"")
                   .replace(/[ \r\n\t]{1,}xmlns/g, ' xmlns');
  return  str.replace(/>\s{0,}</g,"><"); 
}

vkbeautify.prototype.jsonmin = function(text) {

  if (typeof JSON === 'undefined' ) return text; 
  
  return JSON.stringify(JSON.parse(text), null, 0); 
        
}

vkbeautify.prototype.cssmin = function(text, preserveComments) {
  
  var str = preserveComments ? text
                 : text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;

  return str.replace(/\s{1,}/g,' ')
        .replace(/\{\s{1,}/g,"{")
        .replace(/\}\s{1,}/g,"}")
        .replace(/\;\s{1,}/g,";")
        .replace(/\/\*\s{1,}/g,"/*")
        .replace(/\*\/\s{1,}/g,"*/");
}

vkbeautify.prototype.sqlmin = function(text) {
  return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}

//module.exports = new vkbeautify();
  </script>


  <script>
    const XMLNS_NS = 'http://www.w3.org/2000/xmlns/';
    const ANDROID_NS = 'http://schemas.android.com/apk/res/android';
    const AAPT_NS = 'http://schemas.android.com/aapt';

    var xmlDoc = document.implementation.createDocument(null, "books");
    var root = xmlDoc.documentElement;
    root.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
    root.setAttributeNS(XMLNS_NS, 'xmlns:aapt', AAPT_NS);
    root.appendChild(xmlDoc.createElement('hey'));
    // root.setAttributeNS(ANDROID_NS, 'foo:blah', undefined);
    var bar = xmlDoc.createElement('group');
    bar.setAttribute('android:blah', 15123);
    root.appendChild(bar);
    var bar2 = xmlDoc.createElement('group');
    bar2.setAttributeNS(ANDROID_NS, 'android:blah', 15123);
    bar.appendChild(bar2);
    var bar3 = xmlDoc.createElement('foo');
    bar3.setAttributeNS(ANDROID_NS, 'android:blah', 15123);
    bar2.appendChild(bar3);

    // prettyprint
    let xmlStr = new XMLSerializer().serializeToString(root);
    console.log(new vkbeautify().xml(xmlStr, 4));


    // 'use strict';

    // // let parser = new DOMParser();
    // // let doc = parser.parseFromString(svgString, 'image/svg+xml');
    // let doc = document.querySelector('svg');

    // const lengthPx_ = svgLength => {
    //   if (svgLength.baseVal) {
    //     svgLength = svgLength.baseVal;
    //   }
    //   svgLength.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);
    //   return svgLength.valueInSpecifiedUnits;
    // };

    // const transformPoint_ = (p, transforms) => transforms.reduce((p, transform) => {
    //     let m = transform.matrix;
    //     return {
    //       // dot product
    //       x: m.a * p.x + m.c * p.y + m.e * 1,
    //       y: m.b * p.x + m.d * p.y + m.f * 1
    //     };
    //   }, p);

    // const contextAttr_ = (node, context, attr) => {
    //   if (node.attributes[attr]) {
    //     context[attr] = node.attributes[attr].value;
    //   }
    // };

    // const visitNode_ = (node, context) => {
    //   if (node.nodeType == Node.TEXT_NODE || node.nodeType == Node.COMMENT_NODE) {
    //     return;
    //   }

    //   // set attributes
    //   contextAttr_(node, context, 'stroke');
    //   contextAttr_(node, context, 'stroke-width');
    //   contextAttr_(node, context, 'stroke-linecap');
    //   contextAttr_(node, context, 'stroke-opacity');
    //   contextAttr_(node, context, 'fill');
    //   contextAttr_(node, context, 'fill-opacity');
    //   contextAttr_(node, context, 'stroke');

    //   // add transforms
    //   if (node.transform) {
    //     context.transforms = (context.transforms || [])
    //         .concat(Array.from(node.transform.baseVal));
    //   }

    //   // console.log(node.id, context);
    //   console.log(node);
    //   let path;
    //   if (node instanceof SVGPathElement) {
    //     path = node.attributes.d.value;

    //   } else if (node instanceof SVGRectElement) {
    //     let l = lengthPx_(node.x),
    //         t = lengthPx_(node.y),
    //         r = l + lengthPx_(node.width),
    //         b = t + lengthPx_(node.height);
    //     path = `M ${l},${t} ${r},${t} ${r},${b} ${l},${b} Z`;

    //   } else if (node instanceof SVGLineElement) {
    //     let x1 = lengthPx_(node.x1),
    //         y1 = lengthPx_(node.y1),
    //         x2 = lengthPx_(node.x2),
    //         y2 = lengthPx_(node.y2);
    //     path = `M ${x1},${y1} ${x2},${y2} Z`;

    //   } else if (node instanceof SVGPolygonElement || node instanceof SVGPolylineElement) {
    //     path = 'M ' + Array.from(node.points).map(pt => pt.x +',' + pt.y).join(' ');
    //     if (node instanceof SVGPolygonElement) {
    //       path += ' Z';
    //     }

    //   } else if (node instanceof SVGCircleElement) {
    //     let cx = lengthPx_(node.cx),
    //         cy = lengthPx_(node.cy),
    //         r = lengthPx_(node.r);
    //     path = `M ${cx},${cy-r} A ${r} ${r} 0 1 0 ${cx},${cy+r} A ${r} ${r} 0 1 0 ${cx},${cy-r} Z`;

    //   } else if (node instanceof SVGEllipseElement) {
    //     let cx = lengthPx_(node.cx),
    //         cy = lengthPx_(node.cy),
    //         rx = lengthPx_(node.rx),
    //         ry = lengthPx_(node.ry);
    //     path = `M ${cx},${cy-ry} A ${rx} ${ry} 0 1 0 ${cx},${cy+ry} ` +
    //            `A ${rx} ${ry} 0 1 0 ${cx},${cy-ry} Z`;
    //   }

    //   console.log(path);

    //   // visit children
    //   if (node.childNodes.length) {
    //     node.childNodes.forEach(child => visitNode_(child, Object.assign({}, context)));
    //   }
    // };

    // visitNode_(doc, {});
  </script>

</body>
</html>