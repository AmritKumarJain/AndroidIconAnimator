import {ColorUtil} from 'avdstudio/colorutil';
import {SvgPathData} from 'avdstudio/svgpathparser';

// meta (property types)

export class Property {
  interpolateValue(start, end, f) {
    return start;
  }

  getEditableValue(obj, propertyName) {
    return obj[propertyName];
  }

  trySetEditedValue(obj, propertyName, value) {
    obj[propertyName] = value;
  }

  displayValueForValue(val) {
    return val;
  }

  cloneValue(val) {
    return val;
  }
}


export class EnumProperty extends Property {
  constructor(options, extra) {
    super();
    this.optionsByValue_ = {};
    this.options_ = (options || []).map(option => {
      let newOption = {};
      if (typeof option === 'string') {
        newOption = {
          value: option,
          label: option
        };
        option = newOption;
      }

      if (!('label' in option)) {
        option.label = option.value;
      }

      this.optionsByValue_[option.value] = option;
      return option;
    });

    extra = extra || {};
    if (extra.storeEntireOption) {
      this.storeEntireOption = extra.storeEntireOption;
    }
  }

  getter_(obj, propertyName, value) {
    let backingPropertyName = `${propertyName}_`;
    return obj[backingPropertyName];
  }

  setter_(obj, propertyName, value) {
    let backingPropertyName = `${propertyName}_`;

    obj[backingPropertyName] = this.storeEntireOption
        ? this.getOptionForValue_(value)
        : this.getOptionForValue_(value).value;
  }

  getOptionForValue_(value) {
    if (!value) {
      return null;
    }

    if (typeof value === 'string') {
      return this.optionsByValue_[value];
    } else if ('value' in value) {
      return value;
    }

    return null;
  }

  displayValueForValue(value) {
    if (!value) {
      return '';
    }

    return this.getOptionForValue_(value).label;
  }

  get options() {
    return this.options_;
  }
}


export class StringProperty extends Property {
}


export class IdProperty extends Property {
  trySetEditedValue(obj, propertyName, value) {
    obj[propertyName] = IdProperty.sanitize(value);
  }

  static sanitize(value) {
    value = (value || '')
        .toLowerCase()
        .replace(/^\s+|\s+$/g, '')
        .replace(/[\s-]+/g, '_')
        .replace(/[^\w_]+/g, '');
    return value;
  }
}


let simpleInterpolate_ = (start, end, f) => start + (end - start) * f;


export class PathDataProperty extends Property {
  interpolateValue(start, end, f) {
    return SvgPathData.interpolate(start, end, f);
  }

  displayValueForValue(val) {
    return val.pathString;
  }

  getEditableValue(obj, propertyName) {
    return obj[propertyName] ? obj[propertyName].pathString : '';
  }

  trySetEditedValue(obj, propertyName, stringValue) {
    obj[propertyName] = new SvgPathData(stringValue);
  }

  getter_(obj, propertyName) {
    let backingPropertyName = `${propertyName}_`;
    return obj[backingPropertyName];
  }

  setter_(obj, propertyName, value) {
    let backingPropertyName = `${propertyName}_`;
    let pathData;
    if (!value || value instanceof SvgPathData) {
      pathData = value;
    } else {
      pathData = new SvgPathData(value);
    }

    obj[backingPropertyName] = pathData;
  }

  cloneValue(val) {
    return JSON.parse(JSON.stringify(val));
  }

  get animatorValueType() {
    return 'pathType';
  }
}


export class ColorProperty extends Property {
  interpolateValue(start, end, f) {
    start = ColorUtil.parseAndroidColor(start);
    end = ColorUtil.parseAndroidColor(end);
    return ColorUtil.toAndroidString({
      r: Math.max(0, Math.min(Math.round(simpleInterpolate_(start.r, end.r, f)), 255)),
      g: Math.max(0, Math.min(Math.round(simpleInterpolate_(start.g, end.g, f)), 255)),
      b: Math.max(0, Math.min(Math.round(simpleInterpolate_(start.b, end.b, f)), 255)),
      a: Math.max(0, Math.min(Math.round(simpleInterpolate_(start.a, end.a, f)), 255))
    });
  }

  get animatorValueType() {
    return 'colorType';
  }
}


export class NumberProperty extends Property {
  constructor(opts = {}) {
    super();
    this.opts = opts;
  }

  trySetEditedValue(obj, propertyName, value) {
    value = parseFloat(value);
    if (!isNaN(value)) {
      if ('min' in this.opts) {
        value = Math.max(this.opts.min, value);
      }
      if ('max' in this.opts) {
        value = Math.min(this.opts.max, value);
      }
      if (this.opts.integer) {
        value = Math.floor(value);
      }
      obj[propertyName] = value;
    }
  }

  displayValueForValue(value) {
    if (typeof value === 'number') {
      return (Number.isInteger(value)
            ? value.toString()
            : Number(value.toFixed(3)).toString())
          .replace(/-/g, '\u2212');
    }
    return value;
  }

  interpolateValue(start, end, f) {
    return simpleInterpolate_(start, end, f);
  }

  get animatorValueType() {
    return 'floatType';
  }
}


export class FractionProperty extends NumberProperty {
  constructor(opts = {}) {
    opts.min = 0;
    opts.max = 1;
    super(opts);
  }

  get animatorValueType() {
    return 'floatType';
  }
}


// data model


export class BaseLayer {
  constructor(obj = {}, opts = {}) {
    this.parent = null;
    this.id = obj.id || null;
    if (opts && opts.linkSelectedState) {
      this.selectedStateLinkedObj_ = obj;
    }
  }

  getSibling_(offs) {
    if (!this.parent || !this.parent.layers) {
      return null;
    }

    let index = this.parent.layers.indexOf(this);
    if (index < 0) {
      return null;
    }

    index += offs;
    if (index < 0 || index >= this.parent.layers.length) {
      return null;
    }

    return this.parent.layers[index];
  }

  get selected() {
    return this.selectedStateLinkedObj_
        ? this.selectedStateLinkedObj_.selected_
        : this.selected_;
  }

  computeBounds() {
    return null;
  }

  get previousSibling() {
    return this.getSibling_(-1);
  }

  get nextSibling() {
    return this.getSibling_(1);
  }

  remove() {
    if (!this.parent || !this.parent.layers) {
      return;
    }

    let index = this.parent.layers.indexOf(this);
    if (index >= 0) {
      this.parent.layers.splice(index, 1);
    }

    this.parent = null;
  }

  walk(fn, context) {
    let visit_ = (layer, context) => {
      let childContext = fn(layer, context);
      if (layer.layers) {
        walkLayerGroup_(layer, childContext);
      }
    };

    let walkLayerGroup_ = (layerGroup, context) => {
      layerGroup.layers.forEach(layer => visit_(layer, context));
    };

    visit_(this, context);
  }

  toJSON() {
    return {
      id: this.id,
      type: this.typeString,
    };
  }
}


const LAYER_ANIMATABLE_PROPERTIES = {
  'pathData': new PathDataProperty(),
  'strokeColor': new ColorProperty(),
  'strokeWidth': new NumberProperty({min:0}),
  'fillColor': new ColorProperty(),
  'trimPathStart': new FractionProperty(),
  'trimPathEnd': new FractionProperty(),
  'trimPathOffset': new FractionProperty()
};


const ENUM_LINECAP_OPTIONS = [
  {
    value: 'butt',
    label: 'Butt',
  },
  {
    value: 'square',
    label: 'Square',
  },
  {
    value: 'round',
    label: 'Round',
  }
];


const LAYER_INSPECTABLE_PROPERTIES = {
  'id': new IdProperty(),
  'pathData': new PathDataProperty(),
  'strokeColor': new ColorProperty(),
  'strokeWidth': new NumberProperty({min:0}),
  'strokeLinecap': new EnumProperty(ENUM_LINECAP_OPTIONS),
  'fillColor': new ColorProperty(),
  'trimPathStart': new FractionProperty(),
  'trimPathEnd': new FractionProperty(),
  'trimPathOffset': new FractionProperty()
};


export class Layer extends BaseLayer {
  constructor(obj = {}, opts = {}) {
    super(obj, opts);
    this.pathData = obj.pathData || '';
    this.strokeColor = obj.strokeColor || '';
    this.strokeWidth = obj.strokeWidth || 0;
    this.strokeLinecap = obj.strokeLinecap || 'butt';
    this.fillColor = obj.fillColor || null;
    this.trimPathStart = obj.trimPathStart || 0;
    this.trimPathEnd = ('trimPathEnd' in obj && typeof obj.trimPathEnd == 'number')
        ? obj.trimPathEnd : 1;
    this.trimPathOffset = obj.trimPathOffset || 0;
  }

  computeBounds() {
    return Object.assign({}, (this.pathData && this.pathData.bounds) ? this.pathData.bounds : null);
  }

  get pathData() {
    return LAYER_INSPECTABLE_PROPERTIES['pathData'].getter_(this, 'pathData');
  }

  set pathData(pathData) {
    LAYER_INSPECTABLE_PROPERTIES['pathData'].setter_(this, 'pathData', pathData);
  }

  get strokeLinecap() {
    return LAYER_INSPECTABLE_PROPERTIES['strokeLinecap'].getter_(this, 'strokeLinecap');
  }

  set strokeLinecap(linecap) {
    LAYER_INSPECTABLE_PROPERTIES['strokeLinecap'].setter_(this, 'strokeLinecap', linecap);
  }

  get animatableProperties() {
    return Object.assign({}, LAYER_ANIMATABLE_PROPERTIES);
  }

  get inspectableProperties() {
    return Object.assign({}, LAYER_INSPECTABLE_PROPERTIES);
  }

  get typeString() {
    return 'path';
  }

  get typeIdPrefix() {
    return 'path';
  }

  get typeIcon() {
    return 'path_layer';
  }

  toJSON() {
    return Object.assign(super.toJSON(), {
      pathData: this.pathData.pathString,
      strokeColor: this.strokeColor,
      strokeWidth: this.strokeWidth,
      strokeLinecap: this.strokeLinecap,
      fillColor: this.fillColor,
      trimPathStart: this.trimPathStart,
      trimPathEnd: this.trimPathEnd,
      trimPathOffset: this.trimPathOffset
    });
  }

  static load(obj = {}, opts) {
    if (obj instanceof BaseLayer) {
      return new obj.constructor(obj, opts);
    }

    return new LayerClassesByType[obj.type || 'path'](obj, opts);
  }
}


const LAYER_GROUP_ANIMATABLE_PROPERTIES = {
  'rotation': new NumberProperty(),
  'scaleX': new NumberProperty(),
  'scaleY': new NumberProperty(),
  'pivotX': new NumberProperty(),
  'pivotY': new NumberProperty(),
  'translateX': new NumberProperty(),
  'translateY': new NumberProperty()
};


const LAYER_GROUP_INSPECTABLE_PROPERTIES = {
  'id': new IdProperty(),
  'rotation': new NumberProperty(),
  'scaleX': new NumberProperty(),
  'scaleY': new NumberProperty(),
  'pivotX': new NumberProperty(),
  'pivotY': new NumberProperty(),
  'translateX': new NumberProperty(),
  'translateY': new NumberProperty()
};


export class LayerGroup extends BaseLayer {
  constructor(obj = {}, opts = {}) {
    super(obj, opts);
    this.layers = (obj.layers || []).map(obj => Layer.load(obj, opts));
    this.rotation = obj.rotation || 0;
    this.scaleX = ('scaleX' in obj) ? obj.scaleX : 1;
    this.scaleY = ('scaleY' in obj) ? obj.scaleY : 1;
    this.pivotX = obj.pivotX || 0;
    this.pivotY = obj.pivotY || 0;
    this.translateX = obj.translateX || 0;
    this.translateY = obj.translateY || 0;
  }

  get animatableProperties() {
    return Object.assign({}, LAYER_GROUP_ANIMATABLE_PROPERTIES);
  }

  get inspectableProperties() {
    return Object.assign({}, LAYER_GROUP_INSPECTABLE_PROPERTIES);
  }

  computeBounds() {
    let bounds = null;
    this.layers.forEach(child => {
      let childBounds = child.computeBounds();
      if (!childBounds) {
        return;
      }

      if (!bounds) {
        bounds = Object.assign({}, childBounds);
      } else {
        bounds.l = Math.min(childBounds.l, bounds.l);
        bounds.t = Math.min(childBounds.t, bounds.t);
        bounds.r = Math.max(childBounds.r, bounds.r);
        bounds.b = Math.max(childBounds.b, bounds.b);
      }
    });
    return bounds;
  }

  get layers() {
    return this.layers_ || [];
  }

  set layers(layers) {
    this.layers_ = layers;
    this.layers_.forEach(layer => layer.parent = this);
  }

  get typeString() {
    return 'group';
  }

  get typeIdPrefix() {
    return 'group';
  }

  get typeIcon() {
    return 'layer_group';
  }

  findLayerById(id) {
    for (let i = 0; i < this.layers.length; i++) {
      let layer = this.layers[i];
      if (layer.id === id) {
        return layer;
      } else if (layer.findLayerById) {
        layer = layer.findLayerById(id);
        if (layer) {
          return layer;
        }
      }
    }

    return null;
  }

  toJSON() {
    return Object.assign(super.toJSON(), {
      rotation: this.rotation,
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      pivotX: this.pivotX,
      pivotY: this.pivotY,
      translateX: this.translateX,
      translateY: this.translateY,
      layers: this.layers.map(layer => layer.toJSON())
    });
  }
}


const MASK_LAYER_ANIMATABLE_PROPERTIES = {
  'pathData': new PathDataProperty()
};


const MASK_LAYER_INSPECTABLE_PROPERTIES = {
  'id': new IdProperty(),
  'pathData': new PathDataProperty()
};


export class MaskLayer extends BaseLayer {
  constructor(obj = {}, opts = {}) {
    super(obj, opts);
    this.pathData = obj.pathData || '';
  }

  get animatableProperties() {
    return Object.assign({}, MASK_LAYER_ANIMATABLE_PROPERTIES);
  }

  get inspectableProperties() {
    return Object.assign({}, MASK_LAYER_INSPECTABLE_PROPERTIES);
  }

  computeBounds() {
    return Object.assign({}, (this.pathData && this.pathData.bounds) ? this.pathData.bounds : null);
  }

  get pathData() {
    return MASK_LAYER_INSPECTABLE_PROPERTIES['pathData'].getter_(this, 'pathData');
  }

  set pathData(pathData) {
    MASK_LAYER_INSPECTABLE_PROPERTIES['pathData'].setter_(this, 'pathData', pathData);
  }

  get typeString() {
    return 'mask';
  }

  get typeIdPrefix() {
    return 'mask';
  }

  get typeIcon() {
    return 'mask_layer';
  }

  toJSON() {
    return Object.assign(super.toJSON(), {
      pathData: this.pathData.pathString
    });
  }
}


const ARTWORK_INSPECTABLE_PROPERTIES = {
  'id': new IdProperty(),
  'width': new NumberProperty({min:4, max:1024, integer:true}),
  'height': new NumberProperty({min:4, max:1024, integer:true}),
};


export class Artwork extends LayerGroup {
  constructor(obj = {}, opts = {}) {
    super(obj, opts);
    this.id = this.id || this.typeIdPrefix;
    this.width = obj.width || 100;
    this.height = obj.height || 100;
  }

  computeBounds() {
    return { l: 0, t: 0, r: this.width, b: this.height };
  }

  get typeString() {
    return 'artwork';
  }

  get typeIdPrefix() {
    return 'vector';
  }

  get typeIcon() {
    return 'artwork';
  }

  get inspectableProperties() {
    return Object.assign({}, ARTWORK_INSPECTABLE_PROPERTIES);
  }

  get animatableProperties() {
    return null;
  }

  toJSON() {
    return {
      id: this.id,
      width: this.width,
      height: this.height,
      layers: this.layers.map(layer => layer.toJSON())
    };
  }
}


const ANIMATION_INSPECTABLE_PROPERTIES = {
  'id': new IdProperty(),
  'duration': new NumberProperty({min:100, max:60000})
};


export class Animation {
  constructor(obj = {}) {
    this.id = obj.id || null;
    this.blocks = (obj.blocks || []).map(obj => new AnimationBlock(obj));
    this.duration = obj.duration || 100;
  }

  get inspectableProperties() {
    return Object.assign({}, ANIMATION_INSPECTABLE_PROPERTIES);
  }

  get multiInspectableProperties() {
    return Object.assign({}, ANIMATION_INSPECTABLE_PROPERTIES);
  }

  get typeString() {
    return 'animation';
  }

  get typeIdPrefix() {
    return 'anim';
  }

  get typeIcon() {
    return 'animation';
  }

  toJSON() {
    return {
      id: this.id,
      duration: this.duration,
      blocks: this.blocks.map(block => block.toJSON())
    };
  }
}


const ENUM_INTERPOLATOR_OPTIONS = [
  {
    value: 'ACCELERATE_DECELERATE',
    label: 'Accelerate/decelerate',
    androidRef: '@android:anim/accelerate_decelerate_interpolator',
    interpolate: f => Math.cos((f + 1) * Math.PI) / 2.0 + 0.5,
  },
  {
    value: 'ACCELERATE',
    label: 'Accelerate',
    androidRef: '@android:anim/accelerate_interpolator',
    interpolate: f => f * f,
  },
  {
    value: 'DECELERATE',
    label: 'Decelerate',
    androidRef: '@android:anim/decelerate_interpolator',
    interpolate: f => (1 - (1 - f) * (1 - f)),
  },
  {
    value: 'ANTICIPATE',
    label: 'Anticipate',
    androidRef: '@android:anim/anticipate_interpolator',
    interpolate: f => f * f * ((2 + 1) * f - 2),
  },
  {
    value: 'LINEAR',
    label: 'Linear',
    androidRef: '@android:anim/linear_interpolator',
    interpolate: f => f,
  },
  {
    value: 'OVERSHOOT',
    label: 'Overshoot',
    androidRef: '@android:anim/overshoot_interpolator',
    interpolate: f => (f - 1) * (f - 1) * ((2 + 1) * (f - 1) + 2) + 1
  }
  //BOUNCE: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/view/animation/BounceInterpolator.java
  //ANTICIPATE_OVERSHOOT: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/view/animation/AnticipateOvershootInterpolator.java
  //PATH: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/view/animation/PathInterpolator.java
];


const Interpolators = {};
ENUM_INTERPOLATOR_OPTIONS.forEach(interp => Interpolators[interp.value] = interp);


const ANIMATION_BLOCK_INSPECTABLE_PROPERTIES = {
  'fromValue': 'auto',
  'toValue': 'auto',
  'startTime': new NumberProperty(),
  'endTime': new NumberProperty(),
  'interpolator': new EnumProperty(ENUM_INTERPOLATOR_OPTIONS, {storeEntireOption:true})
};


const ANIMATION_BLOCK_MULTI_INSPECTABLE_PROPERTIES = {
  'startTime': new NumberProperty(),
  'endTime': new NumberProperty(),
  'interpolator': new EnumProperty(ENUM_INTERPOLATOR_OPTIONS, {storeEntireOption:true})
};


export class AnimationBlock {
  constructor(obj = {}) {
    this.layerId = obj.layerId || null;
    this.propertyName = obj.propertyName || null;
    let isPathData = (this.propertyName === 'pathData');
    if ('fromValue' in obj) {
      this.fromValue = isPathData ? new SvgPathData(obj.fromValue) : obj.fromValue;
    }
    this.toValue = isPathData ? new SvgPathData(obj.toValue) : obj.toValue;
    this.startTime = obj.startTime || 0;
    this.endTime = obj.endTime || 0;
    if (this.startTime > this.endTime) {
      let tmp = this.endTime;
      this.endTime = this.startTime;
      this.startTime = tmp;
    }
    this.interpolator = obj.interpolator || 'ACCELERATE_DECELERATE';
  }

  get interpolator() {
    return ANIMATION_BLOCK_INSPECTABLE_PROPERTIES['interpolator'].getter_(this, 'interpolator');
  }

  set interpolator(interpolator) {
    ANIMATION_BLOCK_INSPECTABLE_PROPERTIES['interpolator'].setter_(
        this, 'interpolator', interpolator);
  }

  get inspectableProperties() {
    return Object.assign({}, ANIMATION_BLOCK_INSPECTABLE_PROPERTIES);
  }

  get multiInspectableProperties() {
    return Object.assign({}, ANIMATION_BLOCK_MULTI_INSPECTABLE_PROPERTIES);
  }

  get typeString() {
    return 'block';
  }

  get typeIdPrefix() {
    return 'block';
  }

  get typeIcon() {
    return 'animation_block';
  }

  toJSON() {
    return {
      layerId: this.layerId,
      propertyName: this.propertyName,
      fromValue: (this.fromValue && 'toJSON' in this.fromValue)
          ? this.fromValue.toJSON() : this.fromValue,
      toValue: (this.toValue && 'toJSON' in this.toValue)
          ? this.toValue.toJSON() : this.toValue,
      startTime: this.startTime,
      endTime: this.endTime,
      interpolator: this.interpolator.value,
    };
  }
}


const LayerClassesByType = {
  'path': Layer,
  'group': LayerGroup,
  'mask': MaskLayer,
  'artwork': Artwork
};
